#ifndef SPH_INCLUDE
#define SPH_INCLUDE

#define SPH_THREAD_NUM 8
#define SPH_THREAD_NUM_2D 64
#define SPH_THREAD_NUM_3D 512

#define CELL_SCAN_THREAD_NUM 8
#define CELL_SCAN_THREAD_NUM_2D 64
#define CELL_SCAN_THREAD_NUM_3D 512

#define LOG2_CELL_SCAN_THREAD_NUM_3D 9

struct Particle
{
    float mass;
    float inverseDensity;
    float3 position;
    float3 velocity;    
    float3 previousVelocity;
    float3 middleVelocity;
    
    float pressure;
    float forcePressure;
    float forceViscosity;
    float forceTension;
    
    uint cellIndex1d;
};

//
uniform uint _particleNum;
uniform float _timeStep;
uniform uint3 _sphereGridSize;
uniform float _kernelRadius;

uniform float _inverseKernelRadius;
uniform float _kr2;
uniform float _inverseKr3;
uniform float _inverseKr6;
uniform float _inverseKr9;

uniform float _stiffness;
uniform float _restDensity;
uniform float _viscosity;
uniform float _tensionCoef;
uniform float3 _externalAcceleration;

//
static int3 neighborOffset[27] =
{
    int3(-1, -1, -1), int3(0, -1, -1), int3(1, -1, -1),
    int3(-1,  0, -1), int3(0,  0, -1), int3(1,  0, -1),
	  int3(-1,  1, -1), int3(0,  1, -1), int3(1,  1, -1),

	  int3(-1, -1,  0), int3(0, -1,  0), int3(1, -1,  0),
	  int3(-1,  0,  0), int3(0,  0,  0), int3(1,  0,  0),
	  int3(-1,  1,  0), int3(0,  1,  0), int3(1,  1,  0),

	  int3(-1, -1,  1), int3(0, -1,  1), int3(1, -1,  1),
	  int3(-1,  0,  1), int3(0,  0,  1), int3(1,  0,  1),
	  int3(-1,  1,  1), int3(0,  1,  1), int3(1,  1,  1)
};


//
#define kPoly6Const (1.566681471061)
#define gradKPoly6Const (-9.4000888264)
#define lapKPoly6Const (-9.4000888264)
#define kSpikyConst (4.774648292757)
#define gradKSpikyConst (-14.3239448783)
#define kViscosityConst (2.387324146378)
#define lapkViscosityConst (14.3239448783)

//
void FindNeighborSpace(uint3 idx, out uint neighbor[27])
{
	//for(uint p = 0; p < 27; ++p)
	//	neighbor[p] = false;
	 
	 //x + 3y + 9z
	 neighbor[13] = 1;

	 if (idx.x > 0) // (0, 1, 1) -> 12
		neighbor[12] = 1;
	 if (idx.y > 0) // (1, 0, 1) ->10
		neighbor[10] = 1;
     if (idx.z > 0) // (1, 1, 0) -> 4
        neighbor[4] = 1;

     if (idx.x < _sphereGridSize.x - 1) // (2, 1, 1) -> 14
        neighbor[14] = 1;
     if (idx.y < _sphereGridSize.y - 1) // (1, 2, 1) -> 16
        neighbor[16] = 1;
     if (idx.z < _sphereGridSize.z - 1) // (1, 1, 2) -> 22
        neighbor[22] = 1;

     if (idx.x > 0 && idx.y > 0) // (0, 0, 1) -> 9
        neighbor[9] = 1;

     if (idx.y > 0 && idx.z > 0) // (1, 0, 0) -> 1
        neighbor[1] = 1;

     if (idx.x > 0 && idx.z > 0) // (0, 1, 0) -> 3
        neighbor[3] = 1;

     if (idx.x < _sphereGridSize.x - 1 && idx.y < _sphereGridSize.y - 1) // (2, 2, 1) -> 17
        neighbor[17] = 1;

     if (idx.y < _sphereGridSize.y - 1 && idx.z < _sphereGridSize.z - 1) // (1, 2, 2) -> 25
        neighbor[25] = 1;

	 if (idx.x < _sphereGridSize.x - 1 && idx.z < _sphereGridSize.z - 1) // (2, 1, 2) -> 23
        neighbor[23] = 1;

     if (idx.x > 0 && idx.y < _sphereGridSize.y - 1) // (0, 2, 1) -> 15
        neighbor[15] = 1;

     if (idx.y > 0 && idx.z < _sphereGridSize.z - 1) // (1, 0, 2) -> 19
        neighbor[19] = 1;

     if (idx.x > 0 && idx.z < _sphereGridSize.z - 1) // (0, 1, 2) -> 21
        neighbor[21] = 1;

     if (idx.x < _sphereGridSize.x - 1 && idx.y > 0) // (2, 0, 1) -> 11
        neighbor[11] = 1;
     if (idx.y < _sphereGridSize.y - 1 && idx.z > 0) // (1, 2, 0) -> 7
        neighbor[7] = 1;
     if (idx.x < _sphereGridSize.x - 1 && idx.z > 0) // (2, 1, 0) -> 5
        neighbor[5] = 1;
     if (idx.x > 0 && idx.y > 0 && idx.z > 0) // (0, 0, 0) -> 0
         neighbor[0] = 1;

     if (idx.x < _sphereGridSize.x - 1 && idx.y > 0 && idx.z > 0) // (2, 0, 0) -> 2
        neighbor[2] = 1;
     if (idx.x > 0 && idx.y < _sphereGridSize.y - 1 && idx.z > 0) // (0, 2, 0) -> 6
        neighbor[6] = 1;
     if (idx.x > 0 && idx.y > 0 && idx.z < _sphereGridSize.z - 1) // (0, 0, 2) -> 18
        neighbor[18] = 1;

     if (idx.x < _sphereGridSize.x - 1 && idx.y < _sphereGridSize.y - 1 && idx.z > 0) // (2, 2, 0) -> 8
         neighbor[8] = 1; 
	 if (idx.x > 0 && idx.y < _sphereGridSize.y - 1 && idx.z < _sphereGridSize.z - 1) // (0, 2, 2) -> 24
         neighbor[24] = 1;
	 if (idx.x < _sphereGridSize.x - 1 && idx.y > 0 && idx.z < _sphereGridSize.z - 1) // (2, 0, 2) -> 20
         neighbor[20] = 1;
    
	 if (idx.x < _sphereGridSize.x - 1 && idx.y < _sphereGridSize.y - 1 && idx.z < _sphereGridSize.z - 1) // (2, 2, 2) -> 26
         neighbor[26] = 1;
}

//
inline float KernelPoly6(float3 r)
{
    float squareDiff = (_kr2 - dot(r, r));
    if (squareDiff < 0) return 0;
    return kPoly6Const * _inverseKr9 * squareDiff * squareDiff * squareDiff;
}

inline float3 GradKernelPoly6(float3 r)
{
    float squareDiff = (_kr2 - dot(r,r));
    if (squareDiff < 0) return float3(0, 0, 0);
  
    return gradKPoly6Const * _inverseKr9 * squareDiff * squareDiff * r;
}

inline float LaplacianKernelPoly6(float3 r)
{
    float r2 = dot(r, r);
    float squareDiff = (_kr2 - r2);
	  if (squareDiff < 0) return 0;
    return lapKPoly6Const * _inverseKr9 * squareDiff * (3 * _kr2 - 7 * r2);
}

inline float KernelSpiky(float3 r)
{
    float diff = _kernelRadius - length(r);
    if (diff < 0) return 0;
    return kSpikyConst * _inverseKr6 * diff * diff * diff;
}

inline float3 GradKernelSpiky(float3 r)
{
    float mag = length(r);
    float diff = (_kernelRadius - mag);
    if (diff < 0 || mag <= 0) return float3(0, 0, 0);
    r *= (1 / mag);
    return gradKSpikyConst * _inverseKr6 * diff * diff * r;
}

inline float KernelViscosity(float3 r)
{
    float mag = length(r);
    if (_kernelRadius - mag < 0) return 0;
    float sqrMag = mag * mag;
    return kViscosityConst * _inverseKr3 * (-0.5 * mag * sqrMag * _inverseKr3 + sqrMag / (_kr2) + 0.5 * _kernelRadius / mag - 1);
}

inline float LaplacianKernelViscosity(float3 r)
{
    float mag = length(r);
    float diff = _kernelRadius - mag;
    if (diff < 0 || mag <= 0) return 0;
    return lapkViscosityConst * _inverseKr6 * diff;
}

#endif
